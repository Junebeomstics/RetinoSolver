#!/bin/bash
#PBS -l nodes=1:ppn=8,walltime=3:00:00
#PBS -N app-deepRetinotopy
#PBS -V
set -xe

# Brainlife app for deepRetinotopy inference pipeline
# Based on run_deepRetinotopy_freesurfer_with_docker.sh
# Uses Singularity instead of Docker for brainlife compatibility

# Check if jq is available
if ! command -v jq >/dev/null 2>&1; then
    echo "ERROR: jq command is required but not found. Please install jq."
    exit 1
fi

# Check if config.json exists
if [ ! -f "config.json" ]; then
    echo "ERROR: config.json not found in current directory: $(pwd)"
    exit 1
fi

# Read configuration from config.json
FREESURFER_DIR=$(jq -r '.freesurfer' config.json)
MODEL_TYPE=$(jq -r '.model_type' config.json)
PREDICTION=$(jq -r '.prediction_target' config.json)
MYELINATION=$(jq -r '.myelination' config.json)

# Validate required parameters
if [ -z "$FREESURFER_DIR" ] || [ "$FREESURFER_DIR" == "null" ]; then
    echo "ERROR: freesurfer_dir is required in config.json"
    exit 1
fi

if [ -z "$MODEL_TYPE" ] || [ "$MODEL_TYPE" == "null" ]; then
    echo "ERROR: model_type is required in config.json"
    exit 1
fi

if [ -z "$PREDICTION" ] || [ "$PREDICTION" == "null" ]; then
    echo "ERROR: prediction_target is required in config.json"
    exit 1
fi

if [ -z "$MYELINATION" ] || [ "$MYELINATION" == "null" ]; then
    MYELINATION="False"
fi

# Set base directory - CRITICAL: Use current working directory (pwd) for Brainlife
# Brainlife sets up the working directory before running the app
# Do NOT rely on BASH_SOURCE as it may not resolve correctly in job environments
WORKDIR="$(pwd)"
echo "Working directory: $WORKDIR"

# Determine script/project root for accessing model files etc.
# Try multiple methods to find the project root
if [ -f "${BASH_SOURCE[0]}" ]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" 2>/dev/null && pwd)" || SCRIPT_DIR="$WORKDIR"
else
    SCRIPT_DIR="$WORKDIR"
fi

# For Brainlife: the app files are typically in the working directory
# Check if key files exist to verify we're in the right place
if [ -d "$WORKDIR/Models" ] && [ -d "$WORKDIR/run_from_freesurfer" ]; then
    PROJECT_ROOT="$WORKDIR"
elif [ -d "$SCRIPT_DIR/Models" ] && [ -d "$SCRIPT_DIR/run_from_freesurfer" ]; then
    PROJECT_ROOT="$SCRIPT_DIR"
else
    # Fallback: assume current directory is correct
    PROJECT_ROOT="$WORKDIR"
fi

echo "Project root: $PROJECT_ROOT"

# Change to project root if different from current directory
if [ "$PROJECT_ROOT" != "$WORKDIR" ]; then
    cd "$PROJECT_ROOT" || { echo "ERROR: Cannot change to project root: $PROJECT_ROOT"; exit 1; }
    WORKDIR="$PROJECT_ROOT"
fi

# Singularity settings
SINGULARITY_IMAGE=${SINGULARITY_IMAGE:-"docker://vnmd/deepretinotopy_1.0.18:latest"}

# Default parameters
HCP_SURFACE_DIR="surface"
# Use nproc if available, otherwise default to 4 (or use environment variable)
if command -v nproc >/dev/null 2>&1; then
    N_JOBS=$(($(nproc) - 1))
else
    # Fallback: use environment variable or default
    N_JOBS=${NPROC:-4}
fi
[ $N_JOBS -lt 1 ] && N_JOBS=1

# Convert FREESURFER_DIR to absolute path
# Use readlink -f if realpath is not available
if command -v realpath >/dev/null 2>&1; then
    FREESURFER_DIR_ABS=$(realpath "$FREESURFER_DIR" 2>/dev/null || echo "$FREESURFER_DIR")
elif command -v readlink >/dev/null 2>&1; then
    FREESURFER_DIR_ABS=$(readlink -f "$FREESURFER_DIR" 2>/dev/null || echo "$FREESURFER_DIR")
else
    # Fallback: if relative path, make it absolute
    if [[ "$FREESURFER_DIR" != /* ]]; then
        FREESURFER_DIR_ABS="$(pwd)/$FREESURFER_DIR"
    else
        FREESURFER_DIR_ABS="$FREESURFER_DIR"
    fi
fi
if [ ! -d "$FREESURFER_DIR_ABS" ]; then
    echo "ERROR: FreeSurfer directory not found: $FREESURFER_DIR"
    exit 1
fi

# Determine if FREESURFER_DIR is a subject directory or subjects directory
# Check if it has a 'surf' subdirectory (subject directory) or contains subject directories
SUBJECT_ID=""
if [ -d "$FREESURFER_DIR_ABS/surf" ]; then
    # This is a subject directory
    SUBJECT_ID=$(basename "$FREESURFER_DIR_ABS")
    FREESURFER_SUBJECTS_DIR=$(dirname "$FREESURFER_DIR_ABS")
else
    # This is a subjects directory, need to find subject
    # For brainlife, we assume there's one subject
    for item in "$FREESURFER_DIR_ABS"/*; do
        if [ -d "$item" ] && [ -d "$item/surf" ] && [ "$(basename "$item")" != "fsaverage" ]; then
            SUBJECT_ID=$(basename "$item")
            break
        fi
    done
    if [ -z "$SUBJECT_ID" ]; then
        echo "ERROR: Could not find subject directory in $FREESURFER_DIR_ABS"
        exit 1
    fi
    FREESURFER_SUBJECTS_DIR="$FREESURFER_DIR_ABS"
fi

echo "Detected subject ID: $SUBJECT_ID"
echo "FreeSurfer subjects directory: $FREESURFER_SUBJECTS_DIR"

# Map hemisphere names
map_hemisphere() {
    local hemi=$1
    if [[ "${hemi,,}" == "lh" ]]; then
        echo "Left"
    elif [[ "${hemi,,}" == "rh" ]]; then
        echo "Right"
    else
        echo "${hemi}"
    fi
}

# Compose directory and filename patterns for checkpoint search
if [[ "${MYELINATION,,}" == "true" || "${MYELINATION}" == "True" || "${MYELINATION}" == "1" ]]; then
    NO_MYELIN_SUFFIX=""
else
    NO_MYELIN_SUFFIX="_noMyelin"
fi

# Convert to short name for prediction
if [[ "${PREDICTION}" == "eccentricity" ]]; then
    PRED_SHORT="ecc"
elif [[ "${PREDICTION}" == "polarAngle" ]]; then
    PRED_SHORT="PA"
elif [[ "${PREDICTION}" == "pRFsize" ]]; then
    PRED_SHORT="size"
else
    PRED_SHORT="${PREDICTION}"
fi

# Determine model name for file matching
MODEL_NAME="model"
if [ "$MODEL_TYPE" != "baseline" ]; then
    MODEL_NAME="$MODEL_TYPE"
fi

# Create output directories using ABSOLUTE paths
# This is critical for Brainlife - output directories must be consistently accessible
OUTPUT_DIR_FSLR="$WORKDIR/output_prf_fslr"
OUTPUT_DIR_NATIVE="$WORKDIR/output_prf_native"
OUTPUT_DIR_RAW="$WORKDIR/output_raw"
OUTPUT_DIR_STEP1="$WORKDIR/step1_output"

echo "Creating output directories..."
echo "  FSLR output: $OUTPUT_DIR_FSLR"
echo "  Native output: $OUTPUT_DIR_NATIVE"
echo "  Raw output: $OUTPUT_DIR_RAW"
echo "  Step1 output: $OUTPUT_DIR_STEP1"

mkdir -p "$OUTPUT_DIR_FSLR"
mkdir -p "$OUTPUT_DIR_NATIVE"
mkdir -p "$OUTPUT_DIR_RAW"
mkdir -p "$OUTPUT_DIR_STEP1"

# Verify output directories were created
for dir in "$OUTPUT_DIR_FSLR" "$OUTPUT_DIR_NATIVE" "$OUTPUT_DIR_RAW" "$OUTPUT_DIR_STEP1"; do
    if [ ! -d "$dir" ]; then
        echo "ERROR: Failed to create output directory: $dir"
        exit 1
    fi
done

# Create HCP surface directory if it doesn't exist
# This directory is required for Singularity bind mounting
HCP_SURFACE_DIR_ABS="$WORKDIR/$HCP_SURFACE_DIR"
mkdir -p "$HCP_SURFACE_DIR_ABS"

# Process both hemispheres
for HEMISPHERE in lh rh; do
    echo ""
    echo "==============================================="
    echo "Processing Hemisphere: $HEMISPHERE"
    echo "==============================================="
    
    HEMISPHERE_LONG=$(map_hemisphere "$HEMISPHERE")
    HEMI_CHECK="$HEMISPHERE_LONG"
    
    # Find checkpoint based on MODEL_TYPE, PREDICTION, HEMISPHERE, MYELINATION
    DIRNAME="Models/checkpoints/${PREDICTION}_${HEMI_CHECK}_${MODEL_TYPE}${NO_MYELIN_SUFFIX}"
    FILENAME="${PRED_SHORT}_${HEMI_CHECK}_${MODEL_TYPE}${NO_MYELIN_SUFFIX}_best_model_epoch*.pt"
    CHECKPOINT_SEARCH="${DIRNAME}/${FILENAME}"
    
    CHECKPOINT_PATH=$(ls -1 ${CHECKPOINT_SEARCH} 2>/dev/null | sort -V | tail -n 1)
    
    if [[ -z "$CHECKPOINT_PATH" ]]; then
        echo "Error: No checkpoint file found with pattern: ${CHECKPOINT_SEARCH}"
        exit 1
    fi
    
    echo "Using checkpoint: $CHECKPOINT_PATH"
    
    # Determine myelination suffix for filenames
    if [[ "${MYELINATION,,}" == "true" || "${MYELINATION}" == "True" || "${MYELINATION}" == "1" ]]; then
        MYELIN_SUFFIX="_myelin"
    else
        MYELIN_SUFFIX=""
    fi
    
    # Determine model suffix for filenames
    if [ "$MODEL_TYPE" != "baseline" ]; then
        MODEL_SUFFIX="_${MODEL_TYPE}"
    else
        MODEL_SUFFIX=""
    fi
    
    # Convert paths to absolute for bind mounts
    # Use the helper function to resolve paths
    resolve_path() {
        local path="$1"
        if command -v realpath >/dev/null 2>&1; then
            realpath "$path" 2>/dev/null || echo "$path"
        elif command -v readlink >/dev/null 2>&1; then
            readlink -f "$path" 2>/dev/null || echo "$path"
        elif [[ "$path" != /* ]]; then
            echo "$WORKDIR/$path"
        else
            echo "$path"
        fi
    }
    
    CHECKPOINT_PATH_ABS="$(resolve_path "$CHECKPOINT_PATH")"
    # HCP_SURFACE_DIR_ABS is already set above
    PROJECT_ROOT_ABS="$(resolve_path "$PROJECT_ROOT")"
    FREESURFER_SUBJECTS_DIR_ABS="$(resolve_path "$FREESURFER_SUBJECTS_DIR")"
    
    echo "Resolved paths:"
    echo "  Checkpoint: $CHECKPOINT_PATH_ABS"
    echo "  HCP Surface: $HCP_SURFACE_DIR_ABS"
    echo "  Project Root: $PROJECT_ROOT_ABS"
    echo "  FreeSurfer Subjects: $FREESURFER_SUBJECTS_DIR_ABS"
    echo "  Step1 Output: $OUTPUT_DIR_STEP1"
    
    # Build Singularity bind mounts
    # NOTE: step1_output and surface are subdirectories of PROJECT_ROOT, so they're
    # automatically included in the /workspace bind. Do NOT add separate binds for them
    # as overlapping mounts can cause files to not persist correctly.
    BASE_BINDS="-B $PROJECT_ROOT_ABS:/workspace"
    BASE_BINDS="$BASE_BINDS -B $FREESURFER_SUBJECTS_DIR_ABS:/workspace/freesurfer"
    # surface is already at /workspace/surface via the main bind
    
    # Check if checkpoint needs separate bind mount
    CHECKPOINT_BASENAME=$(basename "$CHECKPOINT_PATH_ABS")
    CHECKPOINT_DIR=$(dirname "$CHECKPOINT_PATH_ABS")
    
    # Normalize paths for comparison (remove trailing slashes)
    PROJECT_ROOT_NORM="${PROJECT_ROOT_ABS%/}"
    CHECKPOINT_DIR_NORM="${CHECKPOINT_DIR%/}"
    
    # If checkpoint is within project root, use relative path; otherwise bind it separately
    if [[ "$CHECKPOINT_DIR_NORM" == "$PROJECT_ROOT_NORM"* ]]; then
        # Checkpoint is within project root, use relative path
        CHECKPOINT_REL_PATH="${CHECKPOINT_PATH_ABS#$PROJECT_ROOT_NORM/}"
        CHECKPOINT_PATH_CONTAINER="/workspace/$CHECKPOINT_REL_PATH"
        SINGULARITY_BINDS="$BASE_BINDS"
    else
        # Checkpoint is outside project root, need separate bind
        CHECKPOINT_PATH_CONTAINER="/workspace/checkpoint_dir/$CHECKPOINT_BASENAME"
        SINGULARITY_BINDS="$BASE_BINDS -B $CHECKPOINT_DIR:/workspace/checkpoint_dir"
    fi
    
    echo "Singularity bind mounts configured:"
    echo "  BASE_BINDS: $BASE_BINDS"
    echo "  CHECKPOINT_PATH_CONTAINER: $CHECKPOINT_PATH_CONTAINER"
    
    # Pre-flight checks
    echo ""
    echo "Pre-flight checks..."
    
    # Check HCP surface templates
    HCP_TEMPLATE_L="$HCP_SURFACE_DIR_ABS/fs_LR-deformed_to-fsaverage.L.sphere.32k_fs_LR.surf.gii"
    HCP_TEMPLATE_R="$HCP_SURFACE_DIR_ABS/fs_LR-deformed_to-fsaverage.R.sphere.32k_fs_LR.surf.gii"
    if [ ! -f "$HCP_TEMPLATE_L" ] || [ ! -f "$HCP_TEMPLATE_R" ]; then
        echo "ERROR: HCP surface templates not found in $HCP_SURFACE_DIR_ABS"
        echo "  Required: fs_LR-deformed_to-fsaverage.L.sphere.32k_fs_LR.surf.gii"
        echo "  Required: fs_LR-deformed_to-fsaverage.R.sphere.32k_fs_LR.surf.gii"
        ls -la "$HCP_SURFACE_DIR_ABS/" 2>/dev/null || echo "  (directory not found)"
        exit 1
    fi
    echo "  [OK] HCP surface templates found"
    
    # Check FreeSurfer subject directory
    FS_SUBJECT_DIR="$FREESURFER_SUBJECTS_DIR_ABS/$SUBJECT_ID"
    if [ ! -d "$FS_SUBJECT_DIR/surf" ]; then
        echo "ERROR: FreeSurfer subject surf directory not found: $FS_SUBJECT_DIR/surf"
        echo "  FreeSurfer subjects dir contents:"
        ls -la "$FREESURFER_SUBJECTS_DIR_ABS/" 2>/dev/null | head -20
        exit 1
    fi
    echo "  [OK] FreeSurfer subject directory found: $FS_SUBJECT_DIR"
    
    # Check checkpoint
    if [ ! -f "$CHECKPOINT_PATH_ABS" ]; then
        echo "ERROR: Checkpoint file not found: $CHECKPOINT_PATH_ABS"
        exit 1
    fi
    echo "  [OK] Checkpoint file found"
    
    echo "Pre-flight checks passed!"
    
    # Container paths - step1_output is a subdirectory of /workspace (PROJECT_ROOT)
    # Since we bind PROJECT_ROOT to /workspace, step1_output is at /workspace/step1_output
    CONTAINER_STEP1_OUTPUT="/workspace/step1_output"
    
    # Ensure the output directory exists inside the workspace
    echo "Creating container output directory structure..."
    mkdir -p "$OUTPUT_DIR_STEP1/$SUBJECT_ID/surf"
    mkdir -p "$OUTPUT_DIR_STEP1/$SUBJECT_ID/deepRetinotopy"
    
    # Test that Singularity can write to the output directory
    echo "Testing Singularity write access..."
    TEST_FILE="$OUTPUT_DIR_STEP1/.write_test_$$"
    singularity exec -e $BASE_BINDS \
        "$SINGULARITY_IMAGE" \
        bash -c "echo 'write_test' > /workspace/step1_output/.write_test_$$" 2>&1
    
    if [ -f "$TEST_FILE" ]; then
        echo "  [OK] Singularity can write to output directory"
        rm -f "$TEST_FILE"
    else
        echo "ERROR: Singularity cannot write to output directory"
        echo "  Attempted to create: $TEST_FILE"
        echo "  This indicates a bind mount or permission issue"
        echo "  step1_output directory contents:"
        ls -la "$OUTPUT_DIR_STEP1/" 2>/dev/null
        exit 1
    fi
    
    # Step 1: Native to fsaverage conversion
    echo ""
    echo "[Step 1] Native to fsaverage Conversion"
    echo "==============================================="
    
    STEP1_CMD="cd /workspace/run_from_freesurfer && ./1_native2fsaverage.sh"
    STEP1_CMD="$STEP1_CMD -s /workspace/freesurfer"
    STEP1_CMD="$STEP1_CMD -t /workspace/surface"
    STEP1_CMD="$STEP1_CMD -h $HEMISPHERE"
    STEP1_CMD="$STEP1_CMD -j $N_JOBS"
    STEP1_CMD="$STEP1_CMD -i $SUBJECT_ID"
    STEP1_CMD="$STEP1_CMD -o $CONTAINER_STEP1_OUTPUT"
    
    echo "Running Step 1 command: $STEP1_CMD"
    echo "Bind mounts: $BASE_BINDS"
    
    # Run with verbose output to capture any errors
    singularity exec -e $BASE_BINDS \
        "$SINGULARITY_IMAGE" \
        bash -c "$STEP1_CMD" 2>&1
    
    STEP1_EXIT=$?
    if [ $STEP1_EXIT -ne 0 ]; then
        echo "ERROR: Native to fsaverage conversion failed with exit code $STEP1_EXIT"
        exit 1
    fi
    
    echo "[Step 1] Completed with exit code $STEP1_EXIT"
    
    # Sync filesystem to ensure all files are written
    sync
    
    # Debug: Check what files were created after Step 1
    echo ""
    echo "Checking generated files after native2fsaverage conversion..."
    echo "Looking in: $OUTPUT_DIR_STEP1/$SUBJECT_ID/surf"
    if [ -d "$OUTPUT_DIR_STEP1/$SUBJECT_ID/surf" ]; then
        echo "Directory exists. Contents:"
        ls -la "$OUTPUT_DIR_STEP1/$SUBJECT_ID/surf/" 2>/dev/null | head -20
        echo "GIFTI files:"
        find "$OUTPUT_DIR_STEP1/$SUBJECT_ID/surf" -name "*.gii" -type f 2>/dev/null | head -10
    else
        echo "WARNING: Directory does not exist: $OUTPUT_DIR_STEP1/$SUBJECT_ID/surf"
        echo "Checking parent directory:"
        ls -la "$OUTPUT_DIR_STEP1/" 2>/dev/null | head -10
    fi
    
    # Step 2: Inference
    echo ""
    echo "[Step 2] Running Inference"
    echo "==============================================="
    
    # Use Step 1 output directory as freesurfer_dir for Step 2 (to find template files)
    # Step 2 will save results to output_dir if specified
    # Container paths use the bound mount point
    STEP2_CMD="python /workspace/Models/run_inference_freesurfer.py"
    STEP2_CMD="$STEP2_CMD --freesurfer_dir $CONTAINER_STEP1_OUTPUT"
    STEP2_CMD="$STEP2_CMD --checkpoint_path $CHECKPOINT_PATH_CONTAINER"
    STEP2_CMD="$STEP2_CMD --model_type $MODEL_TYPE"
    STEP2_CMD="$STEP2_CMD --prediction $PREDICTION"
    STEP2_CMD="$STEP2_CMD --hemisphere $HEMISPHERE_LONG"
    STEP2_CMD="$STEP2_CMD --myelination $MYELINATION"
    STEP2_CMD="$STEP2_CMD --subject_id $SUBJECT_ID"
    STEP2_CMD="$STEP2_CMD --output_dir $CONTAINER_STEP1_OUTPUT"
    
    echo "Running Step 2 command: $STEP2_CMD"
    
    singularity exec -e $SINGULARITY_BINDS \
        "$SINGULARITY_IMAGE" \
        bash -c "$STEP2_CMD" 2>&1
    
    STEP2_EXIT=$?
    if [ $STEP2_EXIT -ne 0 ]; then
        echo "ERROR: Inference failed with exit code $STEP2_EXIT"
        exit 1
    fi
    
    echo "[Step 2] Completed with exit code $STEP2_EXIT"
    
    # Sync filesystem to ensure all files are written
    sync
    
    # Debug: Check what files were created after Step 2
    echo ""
    echo "Checking generated files after inference..."
    DEEPRET_DIR="$OUTPUT_DIR_STEP1/$SUBJECT_ID/deepRetinotopy"
    if [ -d "$DEEPRET_DIR" ]; then
        echo "Files in $DEEPRET_DIR:"
        ls -lah "$DEEPRET_DIR/" 2>/dev/null || echo "  (directory exists but listing failed)"
    else
        echo "WARNING: Directory $DEEPRET_DIR does not exist"
        echo "Searching for any generated files in step1_output..."
        find "$OUTPUT_DIR_STEP1" -name "*.func.gii" -type f 2>/dev/null | head -20
        echo "Checking directory structure:"
        ls -laR "$OUTPUT_DIR_STEP1/" 2>/dev/null | head -40
    fi
    
    # Step 3: Fsaverage to native conversion
    echo ""
    echo "[Step 3] Fsaverage to Native Space Conversion"
    echo "==============================================="
    
    # Step 3 needs to read from Step 1 output (surf files) and Step 2 output (prediction files)
    # Use step1_output as freesurfer_dir and specify output_dir to save results there
    # Container paths use the bound mount point
    STEP3_CMD="cd /workspace/run_from_freesurfer && ./2_fsaverage2native.sh"
    STEP3_CMD="$STEP3_CMD -s $CONTAINER_STEP1_OUTPUT"
    STEP3_CMD="$STEP3_CMD -t /workspace/surface"
    STEP3_CMD="$STEP3_CMD -h $HEMISPHERE"
    STEP3_CMD="$STEP3_CMD -r $PREDICTION"
    STEP3_CMD="$STEP3_CMD -m $MODEL_TYPE"
    STEP3_CMD="$STEP3_CMD -y $MYELINATION"
    STEP3_CMD="$STEP3_CMD -j $N_JOBS"
    STEP3_CMD="$STEP3_CMD -i $SUBJECT_ID"
    STEP3_CMD="$STEP3_CMD -o $CONTAINER_STEP1_OUTPUT"
    
    echo "Running Step 3 command: $STEP3_CMD"
    
    singularity exec -e $SINGULARITY_BINDS \
        "$SINGULARITY_IMAGE" \
        bash -c "$STEP3_CMD" 2>&1
    
    STEP3_EXIT=$?
    if [ $STEP3_EXIT -ne 0 ]; then
        echo "ERROR: Fsaverage to native conversion failed with exit code $STEP3_EXIT"
        exit 1
    fi
    
    echo "[Step 3] Completed with exit code $STEP3_EXIT"
    
    # Sync filesystem to ensure all files are written
    sync
    
    # Debug: Check what files were created after Step 3
    echo ""
    echo "Checking generated files after native space conversion..."
    DEEPRET_DIR="$OUTPUT_DIR_STEP1/$SUBJECT_ID/deepRetinotopy"
    if [ -d "$DEEPRET_DIR" ]; then
        echo "Files in $DEEPRET_DIR:"
        ls -lah "$DEEPRET_DIR/" 2>/dev/null || echo "  (directory exists but listing failed)"
    else
        echo "WARNING: deepRetinotopy directory not found"
    fi
    
    # Find and copy output files to new directories with renamed files
    # Find and copy final output files before moving intermediate files
    # Find fsaverage space output file (from Step 2)
    FSLR_OUTPUT_PATTERN="${SUBJECT_ID}.predicted_${PREDICTION}_${HEMISPHERE}${MYELIN_SUFFIX}${MODEL_SUFFIX}.func.gii"
    DEEPRET_DIR="$OUTPUT_DIR_STEP1/$SUBJECT_ID/deepRetinotopy"
    FSLR_OUTPUT_FILE="$DEEPRET_DIR/$FSLR_OUTPUT_PATTERN"
    
    echo "Looking for fsLR output file: $FSLR_OUTPUT_FILE"
    
    if [ -f "$FSLR_OUTPUT_FILE" ]; then
        # Copy to output_prf_fslr with renamed file
        if [ "$HEMISPHERE" == "lh" ]; then
            cp "$FSLR_OUTPUT_FILE" "$OUTPUT_DIR_FSLR/left.gii"
            echo "Copied fsaverage space file to $OUTPUT_DIR_FSLR/left.gii"
        else
            cp "$FSLR_OUTPUT_FILE" "$OUTPUT_DIR_FSLR/right.gii"
            echo "Copied fsaverage space file to $OUTPUT_DIR_FSLR/right.gii"
        fi
    else
        echo "WARNING: Could not find exact match: $FSLR_OUTPUT_FILE"
        # Try to find any matching file with flexible pattern
        echo "Searching for alternative patterns in $DEEPRET_DIR..."
        if [ -d "$DEEPRET_DIR" ]; then
            echo "Directory contents:"
            ls -la "$DEEPRET_DIR/" 2>/dev/null || echo "  (listing failed)"
        fi
        FSLR_FOUND=$(find "$DEEPRET_DIR" -name "*predicted*${PREDICTION}*${HEMISPHERE}*.func.gii" -type f 2>/dev/null | grep -v "native" | head -1)
        if [ -n "$FSLR_FOUND" ] && [ -f "$FSLR_FOUND" ]; then
            echo "Found alternative file: $FSLR_FOUND"
            if [ "$HEMISPHERE" == "lh" ]; then
                cp "$FSLR_FOUND" "$OUTPUT_DIR_FSLR/left.gii"
                echo "Copied fsaverage space file to $OUTPUT_DIR_FSLR/left.gii"
            else
                cp "$FSLR_FOUND" "$OUTPUT_DIR_FSLR/right.gii"
                echo "Copied fsaverage space file to $OUTPUT_DIR_FSLR/right.gii"
            fi
        else
            echo "ERROR: Could not find fsaverage space output file for $HEMISPHERE"
            echo "Searched in: $DEEPRET_DIR"
            echo "Pattern: *predicted*${PREDICTION}*${HEMISPHERE}*.func.gii (excluding native)"
        fi
    fi
    
    # Find native space output file (from Step 3)
    NATIVE_OUTPUT_PATTERN="${SUBJECT_ID}.predicted_${PREDICTION}_${MODEL_NAME}.${HEMISPHERE}.native.func.gii"
    NATIVE_OUTPUT_FILE="$DEEPRET_DIR/$NATIVE_OUTPUT_PATTERN"
    
    echo "Looking for native output file: $NATIVE_OUTPUT_FILE"
    
    if [ -f "$NATIVE_OUTPUT_FILE" ]; then
        # Copy to output_prf_native with renamed file
        if [ "$HEMISPHERE" == "lh" ]; then
            cp "$NATIVE_OUTPUT_FILE" "$OUTPUT_DIR_NATIVE/left.gii"
            echo "Copied native space file to $OUTPUT_DIR_NATIVE/left.gii"
        else
            cp "$NATIVE_OUTPUT_FILE" "$OUTPUT_DIR_NATIVE/right.gii"
            echo "Copied native space file to $OUTPUT_DIR_NATIVE/right.gii"
        fi
    else
        echo "WARNING: Could not find exact match: $NATIVE_OUTPUT_FILE"
        # Try to find any matching file with flexible pattern
        echo "Searching for alternative patterns in $DEEPRET_DIR..."
        NATIVE_FOUND=$(find "$DEEPRET_DIR" -name "*predicted*${PREDICTION}*${HEMISPHERE}*native*.func.gii" -type f 2>/dev/null | head -1)
        if [ -n "$NATIVE_FOUND" ] && [ -f "$NATIVE_FOUND" ]; then
            echo "Found alternative file: $NATIVE_FOUND"
            if [ "$HEMISPHERE" == "lh" ]; then
                cp "$NATIVE_FOUND" "$OUTPUT_DIR_NATIVE/left.gii"
                echo "Copied native space file to $OUTPUT_DIR_NATIVE/left.gii"
            else
                cp "$NATIVE_FOUND" "$OUTPUT_DIR_NATIVE/right.gii"
                echo "Copied native space file to $OUTPUT_DIR_NATIVE/right.gii"
            fi
        else
            echo "ERROR: Could not find native space output file for $HEMISPHERE"
            echo "Searched in: $DEEPRET_DIR"
            echo "Pattern: *predicted*${PREDICTION}*${HEMISPHERE}*native*.func.gii"
        fi
    fi
    
    echo "Hemisphere $HEMISPHERE processing completed!"
done

# After processing both hemispheres, move all intermediate files to output_raw
echo ""
echo "Moving all intermediate files to $OUTPUT_DIR_RAW..."
STEP1_SUBJECT_DIR="$OUTPUT_DIR_STEP1/$SUBJECT_ID"
if [ -d "$STEP1_SUBJECT_DIR" ]; then
    # Move entire subject directory structure to output_raw
    RAW_SUBJECT_DIR="$OUTPUT_DIR_RAW/$SUBJECT_ID"
    mkdir -p "$RAW_SUBJECT_DIR"
    
    # Move all files and directories from step1_output to output_raw
    if [ "$(ls -A "$STEP1_SUBJECT_DIR" 2>/dev/null)" ]; then
        # Use rsync or cp+rm to preserve directory structure
        cp -r "$STEP1_SUBJECT_DIR"/* "$RAW_SUBJECT_DIR/" 2>/dev/null || true
        # Remove the original directory after successful copy
        rm -rf "$STEP1_SUBJECT_DIR" 2>/dev/null || true
        echo "All intermediate files moved to $RAW_SUBJECT_DIR"
    else
        rmdir "$STEP1_SUBJECT_DIR" 2>/dev/null || true
    fi
else
    echo "WARNING: Step1 subject directory not found: $STEP1_SUBJECT_DIR"
fi

echo ""
echo "==============================================="
echo "Full Pipeline Completed!"
echo "==============================================="

# Verify output files were created
echo ""
echo "==============================================="
echo "Verifying output files..."
echo "==============================================="
FSLR_LEFT="$OUTPUT_DIR_FSLR/left.gii"
FSLR_RIGHT="$OUTPUT_DIR_FSLR/right.gii"
NATIVE_LEFT="$OUTPUT_DIR_NATIVE/left.gii"
NATIVE_RIGHT="$OUTPUT_DIR_NATIVE/right.gii"

SUCCESS=true
echo "FSLR space outputs (in $OUTPUT_DIR_FSLR):"
if [ -f "$FSLR_LEFT" ]; then
    echo "  [OK] left.gii ($(du -h "$FSLR_LEFT" | cut -f1))"
else
    echo "  [MISSING] left.gii"
    SUCCESS=false
fi
if [ -f "$FSLR_RIGHT" ]; then
    echo "  [OK] right.gii ($(du -h "$FSLR_RIGHT" | cut -f1))"
else
    echo "  [MISSING] right.gii"
    SUCCESS=false
fi

echo "Native space outputs (in $OUTPUT_DIR_NATIVE):"
if [ -f "$NATIVE_LEFT" ]; then
    echo "  [OK] left.gii ($(du -h "$NATIVE_LEFT" | cut -f1))"
else
    echo "  [MISSING] left.gii"
    SUCCESS=false
fi
if [ -f "$NATIVE_RIGHT" ]; then
    echo "  [OK] right.gii ($(du -h "$NATIVE_RIGHT" | cut -f1))"
else
    echo "  [MISSING] right.gii"
    SUCCESS=false
fi

echo ""
if [ "$SUCCESS" = true ]; then
    echo "Status: SUCCESS - All output files generated"
else
    echo "Status: INCOMPLETE - Some output files are missing"
    echo ""
    echo "Debugging: Listing all .gii files in output directories..."
    echo "FSLR directory contents:"
    ls -la "$OUTPUT_DIR_FSLR/" 2>/dev/null || echo "  (directory not found or empty)"
    echo "Native directory contents:"
    ls -la "$OUTPUT_DIR_NATIVE/" 2>/dev/null || echo "  (directory not found or empty)"
    echo "Raw directory contents:"
    ls -la "$OUTPUT_DIR_RAW/" 2>/dev/null || echo "  (directory not found or empty)"
    echo ""
    echo "All .gii files found:"
    find "$WORKDIR" -name "*.gii" -type f 2>/dev/null | head -30
    exit 1
fi

echo ""
echo "Results are available in:"
echo "  - FSLR space: $OUTPUT_DIR_FSLR/"
echo "  - Native space: $OUTPUT_DIR_NATIVE/"
echo "  - Intermediate files: $OUTPUT_DIR_RAW/"
echo ""
echo "Working directory: $WORKDIR"
