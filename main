#!/bin/bash
#PBS -l nodes=1:ppn=8,walltime=3:00:00
#PBS -N app-deepRetinotopy
#PBS -V
set -xe

# Brainlife app for deepRetinotopy inference pipeline
# Based on run_deepRetinotopy_freesurfer_with_docker.sh
# Uses Singularity instead of Docker for brainlife compatibility

# Check if jq is available
if ! command -v jq >/dev/null 2>&1; then
    echo "ERROR: jq command is required but not found. Please install jq."
    exit 1
fi

# Check if config.json exists
if [ ! -f "config.json" ]; then
    echo "ERROR: config.json not found in current directory: $(pwd)"
    exit 1
fi

# Read configuration from config.json
FREESURFER_DIR=$(jq -r '.freesurfer' config.json)
MODEL_TYPE=$(jq -r '.model_type' config.json)
PREDICTION=$(jq -r '.prediction_target' config.json)
MYELINATION=$(jq -r '.myelination' config.json)

# Validate required parameters
if [ -z "$FREESURFER_DIR" ] || [ "$FREESURFER_DIR" == "null" ]; then
    echo "ERROR: freesurfer_dir is required in config.json"
    exit 1
fi

if [ -z "$MODEL_TYPE" ] || [ "$MODEL_TYPE" == "null" ]; then
    echo "ERROR: model_type is required in config.json"
    exit 1
fi

if [ -z "$PREDICTION" ] || [ "$PREDICTION" == "null" ]; then
    echo "ERROR: prediction_target is required in config.json"
    exit 1
fi

if [ -z "$MYELINATION" ] || [ "$MYELINATION" == "null" ]; then
    MYELINATION="False"
fi

# Set base directory
# For brainlife.io, use current working directory if script path resolution fails
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" 2>/dev/null && pwd)" || SCRIPT_DIR="$(pwd)"
PROJECT_ROOT="$SCRIPT_DIR"
# Try to change directory, but don't fail if already there
cd "$PROJECT_ROOT" 2>/dev/null || true

# Helper function to convert paths to absolute
resolve_abs_path() {
    local path="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath "$path" 2>/dev/null || echo "$path"
    elif command -v readlink >/dev/null 2>&1; then
        readlink -f "$path" 2>/dev/null || echo "$path"
    else
        # Fallback: if relative path, make it absolute
        if [[ "$path" != /* ]]; then
            echo "$(pwd)/$path"
        else
            echo "$path"
        fi
    fi
}

# Singularity settings
SINGULARITY_IMAGE=${SINGULARITY_IMAGE:-"docker://vnmd/deepretinotopy_1.0.18:latest"}

# Default parameters
HCP_SURFACE_DIR="surface"
# Use nproc if available, otherwise default to 4 (or use environment variable)
if command -v nproc >/dev/null 2>&1; then
    N_JOBS=$(($(nproc) - 1))
else
    # Fallback: use environment variable or default
    N_JOBS=${NPROC:-4}
fi
[ $N_JOBS -lt 1 ] && N_JOBS=1

# Convert FREESURFER_DIR to absolute path
# Use readlink -f if realpath is not available
if command -v realpath >/dev/null 2>&1; then
    FREESURFER_DIR_ABS=$(realpath "$FREESURFER_DIR" 2>/dev/null || echo "$FREESURFER_DIR")
elif command -v readlink >/dev/null 2>&1; then
    FREESURFER_DIR_ABS=$(readlink -f "$FREESURFER_DIR" 2>/dev/null || echo "$FREESURFER_DIR")
else
    # Fallback: if relative path, make it absolute
    if [[ "$FREESURFER_DIR" != /* ]]; then
        FREESURFER_DIR_ABS="$(pwd)/$FREESURFER_DIR"
    else
        FREESURFER_DIR_ABS="$FREESURFER_DIR"
    fi
fi
if [ ! -d "$FREESURFER_DIR_ABS" ]; then
    echo "ERROR: FreeSurfer directory not found: $FREESURFER_DIR"
    exit 1
fi

# Determine if FREESURFER_DIR is a subject directory or subjects directory
# Check if it has a 'surf' subdirectory (subject directory) or contains subject directories
SUBJECT_ID=""
if [ -d "$FREESURFER_DIR_ABS/surf" ]; then
    # This is a subject directory
    SUBJECT_ID=$(basename "$FREESURFER_DIR_ABS")
    FREESURFER_SUBJECTS_DIR=$(dirname "$FREESURFER_DIR_ABS")
else
    # This is a subjects directory, need to find subject
    # For brainlife, we assume there's one subject
    for item in "$FREESURFER_DIR_ABS"/*; do
        if [ -d "$item" ] && [ -d "$item/surf" ] && [ "$(basename "$item")" != "fsaverage" ]; then
            SUBJECT_ID=$(basename "$item")
            break
        fi
    done
    if [ -z "$SUBJECT_ID" ]; then
        echo "ERROR: Could not find subject directory in $FREESURFER_DIR_ABS"
        exit 1
    fi
    FREESURFER_SUBJECTS_DIR="$FREESURFER_DIR_ABS"
fi

echo "Detected subject ID: $SUBJECT_ID"
echo "FreeSurfer subjects directory: $FREESURFER_SUBJECTS_DIR"

# Map hemisphere names
map_hemisphere() {
    local hemi=$1
    if [[ "${hemi,,}" == "lh" ]]; then
        echo "Left"
    elif [[ "${hemi,,}" == "rh" ]]; then
        echo "Right"
    else
        echo "${hemi}"
    fi
}

# Compose directory and filename patterns for checkpoint search
if [[ "${MYELINATION,,}" == "true" || "${MYELINATION}" == "True" || "${MYELINATION}" == "1" ]]; then
    NO_MYELIN_SUFFIX=""
else
    NO_MYELIN_SUFFIX="_noMyelin"
fi

# Convert to short name for prediction
if [[ "${PREDICTION}" == "eccentricity" ]]; then
    PRED_SHORT="ecc"
elif [[ "${PREDICTION}" == "polarAngle" ]]; then
    PRED_SHORT="PA"
elif [[ "${PREDICTION}" == "pRFsize" ]]; then
    PRED_SHORT="size"
else
    PRED_SHORT="${PREDICTION}"
fi

# Determine model name for file matching
MODEL_NAME="model"
if [ "$MODEL_TYPE" != "baseline" ]; then
    MODEL_NAME="$MODEL_TYPE"
fi

# Create output directories (using absolute paths)
OUTPUT_DIR_FSLR="$(resolve_abs_path "output_prf_fslr")"
OUTPUT_DIR_NATIVE="$(resolve_abs_path "output_prf_native")"
OUTPUT_DIR_RAW="$(resolve_abs_path "output_raw")"
OUTPUT_DIR_STEP1="$(resolve_abs_path "step1_output")"
mkdir -p "$OUTPUT_DIR_FSLR"
mkdir -p "$OUTPUT_DIR_NATIVE"
mkdir -p "$OUTPUT_DIR_RAW"
mkdir -p "$OUTPUT_DIR_STEP1"

# Create HCP surface directory if it doesn't exist (using absolute path)
HCP_SURFACE_DIR_ABS="$(resolve_abs_path "$HCP_SURFACE_DIR")"
mkdir -p "$HCP_SURFACE_DIR_ABS"

# Process both hemispheres
for HEMISPHERE in lh rh; do
    echo ""
    echo "==============================================="
    echo "Processing Hemisphere: $HEMISPHERE"
    echo "==============================================="
    
    HEMISPHERE_LONG=$(map_hemisphere "$HEMISPHERE")
    HEMI_CHECK="$HEMISPHERE_LONG"
    
    # Find checkpoint based on MODEL_TYPE, PREDICTION, HEMISPHERE, MYELINATION
    DIRNAME="Models/checkpoints/${PREDICTION}_${HEMI_CHECK}_${MODEL_TYPE}${NO_MYELIN_SUFFIX}"
    FILENAME="${PRED_SHORT}_${HEMI_CHECK}_${MODEL_TYPE}${NO_MYELIN_SUFFIX}_best_model_epoch*.pt"
    CHECKPOINT_SEARCH="${DIRNAME}/${FILENAME}"
    
    CHECKPOINT_PATH=$(ls -1 ${CHECKPOINT_SEARCH} 2>/dev/null | sort -V | tail -n 1)
    
    if [[ -z "$CHECKPOINT_PATH" ]]; then
        echo "Error: No checkpoint file found with pattern: ${CHECKPOINT_SEARCH}"
        exit 1
    fi
    
    echo "Using checkpoint: $CHECKPOINT_PATH"
    
    # Determine myelination suffix for filenames
    if [[ "${MYELINATION,,}" == "true" || "${MYELINATION}" == "True" || "${MYELINATION}" == "1" ]]; then
        MYELIN_SUFFIX="_myelin"
    else
        MYELIN_SUFFIX=""
    fi
    
    # Determine model suffix for filenames
    if [ "$MODEL_TYPE" != "baseline" ]; then
        MODEL_SUFFIX="_${MODEL_TYPE}"
    else
        MODEL_SUFFIX=""
    fi
    
    # Convert all paths to absolute (no bind mounts needed - Singularity can access host paths directly)
    CHECKPOINT_PATH_ABS="$(resolve_abs_path "$CHECKPOINT_PATH")"
    PROJECT_ROOT_ABS="$(resolve_abs_path "$PROJECT_ROOT")"
    FREESURFER_SUBJECTS_DIR_ABS="$(resolve_abs_path "$FREESURFER_SUBJECTS_DIR")"
    # OUTPUT_DIR_STEP1 is already absolute from above, but ensure it's resolved
    OUTPUT_DIR_STEP1_ABS="$OUTPUT_DIR_STEP1"
    
    # All paths are now absolute - use them directly in container commands
    # No bind mounts needed - Singularity can access host filesystem directly
    
    # Step 1: Native to fsaverage conversion
    echo ""
    echo "[Step 1] Native to fsaverage Conversion"
    echo "==============================================="
    
    STEP1_SCRIPT="$PROJECT_ROOT_ABS/run_from_freesurfer/1_native2fsaverage.sh"
    
    # Verify script exists before execution
    if [ ! -f "$STEP1_SCRIPT" ]; then
        echo "ERROR: Step 1 script not found: $STEP1_SCRIPT"
        exit 1
    fi
    
    STEP1_CMD="bash $STEP1_SCRIPT"
    STEP1_CMD="$STEP1_CMD -s $FREESURFER_SUBJECTS_DIR_ABS"
    STEP1_CMD="$STEP1_CMD -t $HCP_SURFACE_DIR_ABS"
    STEP1_CMD="$STEP1_CMD -h $HEMISPHERE"
    STEP1_CMD="$STEP1_CMD -j $N_JOBS"
    STEP1_CMD="$STEP1_CMD -i $SUBJECT_ID"
    STEP1_CMD="$STEP1_CMD -o $OUTPUT_DIR_STEP1_ABS"
    
    echo "Executing Step 1 command:"
    echo "  Script: $STEP1_SCRIPT"
    echo "  Full command: $STEP1_CMD"
    echo ""
    
    # Verify script is accessible inside container
    echo "Verifying script accessibility in container..."
    singularity exec -e \
        "$SINGULARITY_IMAGE" \
        bash -c "test -f '$STEP1_SCRIPT' && echo 'Script found' || echo 'Script NOT found: $STEP1_SCRIPT'" 2>&1
    
    echo ""
    echo "Starting Step 1 execution..."
    echo "----------------------------------------"
    
    # Execute and capture both stdout and stderr
    # Use unbuffered output to ensure script echo statements are visible
    singularity exec -e \
        "$SINGULARITY_IMAGE" \
        bash -c "stdbuf -oL -eL $STEP1_CMD" 2>&1
    
    STEP1_EXIT=$?
    
    echo "----------------------------------------"
    echo "Step 1 exit code: $STEP1_EXIT"
    if [ $STEP1_EXIT -ne 0 ]; then
        echo "ERROR: Native to fsaverage conversion failed with exit code $STEP1_EXIT"
        exit 1
    fi
    
    echo ""
    echo "[Step 1] Completed!"
    
    # Debug: Check what files were created after Step 1
    echo ""
    echo "Checking generated files after native2fsaverage conversion..."
    if [ -d "$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/surf" ]; then
        find "$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/surf" -name "*.gii" -o -name "*.mgz" -o -name "*.nii*" 2>/dev/null | head -10
    fi
    
    # Step 2: Inference
    echo ""
    echo "[Step 2] Running Inference"
    echo "==============================================="
    
    # Use Step 1 output directory as freesurfer_dir for Step 2 (to find template files)
    # Step 2 will save results to output_dir if specified
    STEP2_CMD="python $PROJECT_ROOT_ABS/Models/run_inference_freesurfer.py"
    STEP2_CMD="$STEP2_CMD --freesurfer_dir $OUTPUT_DIR_STEP1_ABS"
    STEP2_CMD="$STEP2_CMD --checkpoint_path $CHECKPOINT_PATH_ABS"
    STEP2_CMD="$STEP2_CMD --model_type $MODEL_TYPE"
    STEP2_CMD="$STEP2_CMD --prediction $PREDICTION"
    STEP2_CMD="$STEP2_CMD --hemisphere $HEMISPHERE_LONG"
    STEP2_CMD="$STEP2_CMD --myelination $MYELINATION"
    STEP2_CMD="$STEP2_CMD --subject_id $SUBJECT_ID"
    STEP2_CMD="$STEP2_CMD --output_dir $OUTPUT_DIR_STEP1_ABS"
    
    echo "Executing Step 2 command:"
    echo "  $STEP2_CMD"
    echo ""
    
    singularity exec -e \
        "$SINGULARITY_IMAGE" \
        bash -c "stdbuf -oL -eL $STEP2_CMD" 2>&1
    
    STEP2_EXIT=$?
    echo "Step 2 exit code: $STEP2_EXIT"
    if [ $STEP2_EXIT -ne 0 ]; then
        echo "ERROR: Inference failed with exit code $STEP2_EXIT"
        exit 1
    fi
    
    echo "[Step 2] Completed!"
    
    # Debug: Check what files were created after Step 2
    echo ""
    echo "Checking generated files after inference..."
    if [ -d "$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy" ]; then
        echo "Files in $OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy:"
        ls -lah "$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy/" 2>/dev/null || echo "  (directory exists but listing failed)"
    else
        echo "WARNING: Directory $OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy does not exist"
        echo "Searching for any generated files..."
        find "$OUTPUT_DIR_STEP1_ABS" -name "*.func.gii" -type f 2>/dev/null | head -20
    fi
    
    # Step 3: Fsaverage to native conversion
    echo ""
    echo "[Step 3] Fsaverage to Native Space Conversion"
    echo "==============================================="
    
    # Step 3 needs to read from Step 1 output (surf files) and Step 2 output (prediction files)
    # Use step1_output as freesurfer_dir and specify output_dir to save results there
    STEP3_SCRIPT="$PROJECT_ROOT_ABS/run_from_freesurfer/2_fsaverage2native.sh"
    
    # Verify script exists before execution
    if [ ! -f "$STEP3_SCRIPT" ]; then
        echo "ERROR: Step 3 script not found: $STEP3_SCRIPT"
        exit 1
    fi
    
    STEP3_CMD="bash $STEP3_SCRIPT"
    STEP3_CMD="$STEP3_CMD -s $OUTPUT_DIR_STEP1_ABS"
    STEP3_CMD="$STEP3_CMD -t $HCP_SURFACE_DIR_ABS"
    STEP3_CMD="$STEP3_CMD -h $HEMISPHERE"
    STEP3_CMD="$STEP3_CMD -r $PREDICTION"
    STEP3_CMD="$STEP3_CMD -m $MODEL_TYPE"
    STEP3_CMD="$STEP3_CMD -y $MYELINATION"
    STEP3_CMD="$STEP3_CMD -j $N_JOBS"
    STEP3_CMD="$STEP3_CMD -i $SUBJECT_ID"
    STEP3_CMD="$STEP3_CMD -o $OUTPUT_DIR_STEP1_ABS"
    
    echo "Executing Step 3 command:"
    echo "  Script: $STEP3_SCRIPT"
    echo "  Full command: $STEP3_CMD"
    echo ""
    
    singularity exec -e \
        "$SINGULARITY_IMAGE" \
        bash -c "stdbuf -oL -eL $STEP3_CMD" 2>&1
    
    STEP3_EXIT=$?
    echo "Step 3 exit code: $STEP3_EXIT"
    if [ $STEP3_EXIT -ne 0 ]; then
        echo "ERROR: Fsaverage to native conversion failed with exit code $STEP3_EXIT"
        exit 1
    fi
    
    echo "[Step 3] Completed!"
    
    # Debug: Check what files were created after Step 3
    echo ""
    echo "Checking generated files after native space conversion..."
    if [ -d "$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy" ]; then
        echo "Files in $OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy:"
        ls -lah "$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy/" 2>/dev/null || echo "  (directory exists but listing failed)"
    fi
    
    # Find and copy output files to new directories with renamed files
    # Find and copy final output files before moving intermediate files
    # Find fsaverage space output file (from Step 2)
    FSLR_OUTPUT_PATTERN="${SUBJECT_ID}.predicted_${PREDICTION}_${HEMISPHERE}${MYELIN_SUFFIX}${MODEL_SUFFIX}.func.gii"
    FSLR_OUTPUT_FILE="$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy/$FSLR_OUTPUT_PATTERN"
    
    if [ -f "$FSLR_OUTPUT_FILE" ]; then
        # Copy to output_prf_fslr with renamed file
        if [ "$HEMISPHERE" == "lh" ]; then
            cp "$FSLR_OUTPUT_FILE" "$OUTPUT_DIR_FSLR/left.gii"
            echo "Copied fsaverage space file to $OUTPUT_DIR_FSLR/left.gii"
        else
            cp "$FSLR_OUTPUT_FILE" "$OUTPUT_DIR_FSLR/right.gii"
            echo "Copied fsaverage space file to $OUTPUT_DIR_FSLR/right.gii"
        fi
    else
        echo "WARNING: Could not find exact match: $FSLR_OUTPUT_FILE"
        # Try to find any matching file with flexible pattern
        echo "Searching for alternative patterns..."
        FSLR_FOUND=$(find "$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy" -name "*predicted*${PREDICTION}*${HEMISPHERE}*.func.gii" -type f 2>/dev/null | grep -v "native" | head -1)
        if [ -n "$FSLR_FOUND" ] && [ -f "$FSLR_FOUND" ]; then
            echo "Found alternative file: $FSLR_FOUND"
            if [ "$HEMISPHERE" == "lh" ]; then
                cp "$FSLR_FOUND" "$OUTPUT_DIR_FSLR/left.gii"
                echo "Copied fsaverage space file to $OUTPUT_DIR_FSLR/left.gii"
            else
                cp "$FSLR_FOUND" "$OUTPUT_DIR_FSLR/right.gii"
                echo "Copied fsaverage space file to $OUTPUT_DIR_FSLR/right.gii"
            fi
        else
            echo "ERROR: Could not find fsaverage space output file for $HEMISPHERE"
        fi
    fi
    
    # Find native space output file (from Step 3)
    NATIVE_OUTPUT_PATTERN="${SUBJECT_ID}.predicted_${PREDICTION}_${MODEL_NAME}.${HEMISPHERE}.native.func.gii"
    NATIVE_OUTPUT_FILE="$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy/$NATIVE_OUTPUT_PATTERN"
    
    if [ -f "$NATIVE_OUTPUT_FILE" ]; then
        # Copy to output_prf_native with renamed file
        if [ "$HEMISPHERE" == "lh" ]; then
            cp "$NATIVE_OUTPUT_FILE" "$OUTPUT_DIR_NATIVE/left.gii"
            echo "Copied native space file to $OUTPUT_DIR_NATIVE/left.gii"
        else
            cp "$NATIVE_OUTPUT_FILE" "$OUTPUT_DIR_NATIVE/right.gii"
            echo "Copied native space file to $OUTPUT_DIR_NATIVE/right.gii"
        fi
    else
        echo "WARNING: Could not find exact match: $NATIVE_OUTPUT_FILE"
        # Try to find any matching file with flexible pattern
        echo "Searching for alternative patterns..."
        NATIVE_FOUND=$(find "$OUTPUT_DIR_STEP1_ABS/$SUBJECT_ID/deepRetinotopy" -name "*predicted*${PREDICTION}*${HEMISPHERE}*native*.func.gii" -type f 2>/dev/null | head -1)
        if [ -n "$NATIVE_FOUND" ] && [ -f "$NATIVE_FOUND" ]; then
            echo "Found alternative file: $NATIVE_FOUND"
            if [ "$HEMISPHERE" == "lh" ]; then
                cp "$NATIVE_FOUND" "$OUTPUT_DIR_NATIVE/left.gii"
                echo "Copied native space file to $OUTPUT_DIR_NATIVE/left.gii"
            else
                cp "$NATIVE_FOUND" "$OUTPUT_DIR_NATIVE/right.gii"
                echo "Copied native space file to $OUTPUT_DIR_NATIVE/right.gii"
            fi
        else
            echo "ERROR: Could not find native space output file for $HEMISPHERE"
        fi
    fi
    
    echo "Hemisphere $HEMISPHERE processing completed!"
done

# After processing both hemispheres, move all intermediate files to output_raw
echo ""
echo "Moving all intermediate files to $OUTPUT_DIR_RAW..."
# OUTPUT_DIR_STEP1 is already absolute path
if [ -d "$OUTPUT_DIR_STEP1/$SUBJECT_ID" ]; then
    # Move entire subject directory structure to output_raw
    RAW_SUBJECT_DIR="$OUTPUT_DIR_RAW/$SUBJECT_ID"
    mkdir -p "$RAW_SUBJECT_DIR"
    
    # Move all files and directories from step1_output to output_raw
    if [ "$(ls -A "$OUTPUT_DIR_STEP1/$SUBJECT_ID" 2>/dev/null)" ]; then
        # Use rsync or cp+rm to preserve directory structure
        cp -r "$OUTPUT_DIR_STEP1/$SUBJECT_ID"/* "$RAW_SUBJECT_DIR/" 2>/dev/null || true
        # Remove the original directory after successful copy
        rm -rf "$OUTPUT_DIR_STEP1/$SUBJECT_ID" 2>/dev/null || true
        echo "All intermediate files moved to $RAW_SUBJECT_DIR"
    else
        rmdir "$OUTPUT_DIR_STEP1/$SUBJECT_ID" 2>/dev/null || true
    fi
fi

echo ""
echo "==============================================="
echo "Full Pipeline Completed!"
echo "==============================================="

# Verify output files were created
echo ""
echo "Verifying output files..."
FSLR_LEFT="$OUTPUT_DIR_FSLR/left.gii"
FSLR_RIGHT="$OUTPUT_DIR_FSLR/right.gii"
NATIVE_LEFT="$OUTPUT_DIR_NATIVE/left.gii"
NATIVE_RIGHT="$OUTPUT_DIR_NATIVE/right.gii"

SUCCESS=true
echo "FSLR space outputs:"
if [ -f "$FSLR_LEFT" ]; then
    echo "  ✓ left.gii ($(du -h "$FSLR_LEFT" | cut -f1))"
else
    echo "  ✗ left.gii (MISSING)"
    SUCCESS=false
fi
if [ -f "$FSLR_RIGHT" ]; then
    echo "  ✓ right.gii ($(du -h "$FSLR_RIGHT" | cut -f1))"
else
    echo "  ✗ right.gii (MISSING)"
    SUCCESS=false
fi

echo "Native space outputs:"
if [ -f "$NATIVE_LEFT" ]; then
    echo "  ✓ left.gii ($(du -h "$NATIVE_LEFT" | cut -f1))"
else
    echo "  ✗ left.gii (MISSING)"
    SUCCESS=false
fi
if [ -f "$NATIVE_RIGHT" ]; then
    echo "  ✓ right.gii ($(du -h "$NATIVE_RIGHT" | cut -f1))"
else
    echo "  ✗ right.gii (MISSING)"
    SUCCESS=false
fi

echo ""
if [ "$SUCCESS" = true ]; then
    echo "Status: SUCCESS - All output files generated"
else
    echo "Status: INCOMPLETE - Some output files are missing"
    echo ""
    echo "Debugging: Listing all .gii files in output directories..."
    find "$OUTPUT_DIR_FSLR" "$OUTPUT_DIR_NATIVE" -name "*.gii" -type f 2>/dev/null
    exit 1
fi

echo ""
echo "Results are available in:"
echo "  - FSLR space: $OUTPUT_DIR_FSLR/"
echo "  - Native space: $OUTPUT_DIR_NATIVE/"
echo "  - Intermediate files: $OUTPUT_DIR_RAW/"
